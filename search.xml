<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F11%2F09%2Fdocker%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[title: docker技术详解date: 2019-11-09 17:56:52tags: dockercategories: 虚拟容器copyright: true Docker 和 VM的区别传统的虚拟机VM需要模拟整台机器包括硬件资源，每台虚拟机都会拥有自己的操作系统。虚拟机一旦开启，就会占用预分配的资源，包括必要的二进制和库，以及第一个完整的操作系统。 容器技术与虚拟机不同的是：容器技术可以和宿主机共享硬件资源以及操作系统。容器可以包含自己的应用和相应的依赖包，但与宿主机公用内核。 通过将应用和相关依赖打包为一个文件系统，运行这个文件，就会生成一个虚拟的容器，该容器以进程的形式在宿主机上存活，并和宿主机之间的进程进行隔离，看上去，就好像该程序在真实的物理机上运行。 通过docker和虚拟机对比，我们不难发现，docker技术的优势： 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般是几十个 Docker 三个重要概念 镜像(images) 仓库(Repository) 容器(Container) 简单的来说，就是通过仓库可以管理我们的镜像文件，通过镜像文件就可以生成容器。 镜像docker 镜像可以理解为特殊的文件系统，包括运行时所需要的程序、库资源、配置。镜像不包含$\color{red}{动态数据}$，一旦构建出镜像，镜像的内容就不会变化。 镜像就是一堆只读层(read-only layer)的统一视角，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 (union file system) 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。 镜像基本命令 列出本地主机上的镜像 1docker images 从仓库获取镜像文件 123docker pull 镜像名:tag如果省略后面的tag,如docker pull 镜像名 则会从仓库拉取latest的镜像文件 运行镜像文件 123456789docker run -i -t 镜像名：tag /bin/bash-i: 启动交互式-t: 启动终端/bin/bash: 启动交互式的bash sheldocker run -it -d -p 8080:8080 tomcat-d:后台运行-p:主机端口：docker容器端口-P:随机分配端口 删除镜像文件 1docker rmi 镜像名:tag Dockerfile前面讲到了镜像，那么镜像如何产生的，肯定不能凭空产生，它是怎么产生的呢？我们就要讲到Dockerfile了。Dockerfile使用来构建镜像的，通过在Dockerfile文件中，我们加入对构建镜像的过程基本操作，在构建镜像时，docker就会根据Dockerfile中的定义来构建镜像。下面来聊聊Dockerfile文件 Dockerfile文件的基本结构一本分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器操作指令。 FROM : 指定基础镜像，必须为第一个指令，就是在基础镜像上做一系列操作，记得上面讲的镜像文件都是分层的文件系统了吗?在基础镜像上每做一次操作，就会再基础镜像上包了一层。 12345格式：FROM &lt;image&gt;:&lt;tag&gt;eg:FROM tomcat注意如果没有指定tag，则默认为latest版本的镜像 MAINTAINER 维护者信息 123格式：MAINTAINER &lt;name&gt;MAINTAINER ZMH RUN 用于构建镜像时执行的命令 1234567RUN 有两种语法格式：shell格式： RUN &lt;command&gt; 此处的command为你要执行的shell命令exec执行： RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]注意：RUN指令创建的中间镜像会被缓存，并会在下次构建中使用，如果不想使用这些镜像，可以在构建镜像时指定--no-cache参数，如docker build --no-cache ADD 将本地文件 添加到容器中，tar类型的文件会自动解压(网络压缩资源不会被解压) 12345格式：ADD &lt;src&gt;...&lt;dest&gt;ADD [&quot;&lt;src&gt;&quot;,...&lt;dest&gt;&quot;]支持包含空格的路径egADD hom*.gz /mydir #将当前目录得出hom开头的gz文件添加到mydir，并解压缩 COPY 12格式： COPY &lt;src&gt;(本地) &lt;dest&gt;(容器) 注意ADD和COPY都可以将本地文件复制到容器中，但是ADD可以将类似的压缩文件自动解压缩，而COPY不行，ADD功能更强大 CMD 用于镜像运行容器时调用 123456格式：CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件优先)CMD command param1 (执行shell)egCMD echo &quot;hello,I&apos;m in containering&quot;CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;] 和RUN不同，CMD命令在运行镜像生成容器时运行命令，RUN在构建镜像的过程中运行 ENTERPOINT 配置容器，使其可执行化，只能有一个ENTERPOINT命令。配合CMD可省去”executable”,只使用参数 123456格式：ENTERPOINT [&quot;executable&quot;,&quot;param1&quot;](可执行文件优先)ENTERPOINT command param1egENTERPOINT [&quot;top&quot;,&quot;-b&quot;]CMD [&quot;-c&quot;] 注意ENTERPOINT和CMD非常类似，但是对于CMD来说，如果通过docker run 执行命令启动容器时指定命令，会将dockerfile中CMD命令覆盖。对于ENTERPOINT来说，不会覆盖，只是追加。 ENV 设置环境变量 12格式：ENV &lt;key&gt; &lt;value&gt; EXPOSE 指定外界交互端口 12EXPOSE &lt;port&gt;注意：EXPOSE并不会让容器的端口访问到主机，要使其可访问，需要在docker run 运行容器时通过-p 指定固定端口，或者通过-P参数发布EXPOSE 导出的所有端口 VOLUME 容器数据持久化 12345格式：VOLUME [path]egVOLUME /foo这表示，在docker运行时，docker会创建一个匿名的volume，并将此volume绑定到container的/foo目录中，如果container的/foo目录下已经有内容，则会将内容拷贝的volume中。也即，Dockerfile中的VOLUME /foo与docker run -v /foo alpine的效果一样. WORKDIR 工作目录 123格式：WORKDIR: 工作目录通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录 通过以上命令讲解，可以touch Dockerfile文件，根据需要填写配置信息，Dockerfile文件构建完成后，通过 123docker build -f path/to/Dcokerfile -t 库名/镜像名:tag-f dockerfile 文件路径-t 镜像的名字及标签，通常 name:tag 或者 name 格式 这样你就可以对基础镜像进行改造，通过Dockerfile文件对基础镜像进行操作，使他一层包一层，就可得到自己想要的镜像。 容器基本命令 启动一个容器 12docker run -d 镜像名 -d 后台运行 查询所有容器 1docker ps -a 开启容器 1docker start 容器id 停止容器 1docker stop 容器id 重启容器 1docker restart 容器id 退出容器 12如果要退出容器，并关闭容器的做法是 exit如果要退出容器不关闭容器：Ctrl+P+Q 进入容器 12在使用-d 或者Ctrl+P+Q让容器在后台运行时，想进入容器时，通过执行docker attach 容器id exec命令 123docker exec -it 容器id /bin/bash 执行交互式的shellexec 其实就是进入容器后执行，命令，并返回结果如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 docker exec 的原因 查看容器详细信息 1docker inspect 容器id 将容器内文件拷贝到宿主机 1docker cp 容器id:容器内路径 目的主机路径 持久化docker 的数据持久化不随着container的结束而结束，数据存于host主机指定目录（bind mount）要么使用docker自己管理的volume（/var/lib/docker/volumes下）。 使用volume volume也是绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes。 将my-volume挂载到container中的/mydata目录： 1docker run -it -v my-volume:/mydata alpine sh 然后可以查看到给my-volume的volume： 123456789101112docker volume inspect my-volume[ &#123; "CreatedAt": "2018-03-28T14:52:49Z", "Driver": "local", "Labels": null, "Mountpoint": "/var/lib/docker/volumes/my-volume/_data", "Name": "my-volume", "Options": &#123;&#125;, "Scope": "local" &#125;] 可以看到，volume在host机器的目录为/var/lib/docker/volumes/my-volume/_data。此时，如果my-volume不存在，那么docker会自动创建my-volume，然后再挂载。 也可以不指定host上的volume： 1docker run -it -v /mydata alpine sh 此时docker将自动创建一个匿名的volume，并将其挂载到container中的/mydata目录。匿名volume在host机器上的目录路径类似于：/var/lib/docker/volumes/300c2264cd0acfe862507eedf156eb61c197720f69e7e9a053c87c2182b2e7d8/_data。 除了让docker帮我们自动创建volume，我们也可以自行创建： 1docker volume create my-volume-2 然后将这个已有的my-volume-2挂载到container中: 1docker run -it -v my-volume-2:/mydata alpine sh 需要注意的是，与bind mount不同的是，如果volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中，但是如果volume中已经有内容，则会将container中的目录覆盖。请参考这里。 常用命令图 命令有很多，日常还是多多积累，我相信通过这个图，很清晰的看到命令执行情况。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Springcloud熔断器Hystix]]></title>
    <url>%2F2019%2F08%2F31%2FSpringcloud%E7%86%94%E6%96%AD%E5%99%A8Hystix%2F</url>
    <content type="text"><![CDATA[熔断器雪崩效应在微服务架构中，通常存在多个服务调用，基础微服务不可用将会导致级联故障，从而导致整个系统不可用。雪崩效应就是因为服务提供者不可用，才会导致服务消费者不可用，并将这个过程逐渐放大。 熔断器熔断器的原理如下：它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不在访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修复错误，因为如果存在单个服务不可用，调用这个服务就会出现线程阻塞，此时如果有大量的请求涌入，Servlet容器的线程资源将会被消耗完毕，导致服务瘫痪。 熔断器会记录最近调用发生错误的次数，如果次数达到了指定的阈值，他会决定是否允许执行操作，或者立即返回错误。 Hystrix特性 断路器很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力. FallbackFallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存 资源隔离在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源. Feign Hystrix熔断的作用只是在服务调用这一端，只需要改动服务调用的配置和代码即可 因为Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动. 1、配置文件application.peoperties 1feign.hystrix.enabled=true 2、创建错误回调类，实现Feign自定义的接口 12345678910@Componentpublic class HelloRemoteHystrix implements HelloRemote&#123; @Override public String hello(@RequestParam(value="name") String name)&#123; return "hello :"+name+",this message send failed"; &#125;&#125; 3、在Feign自定义接口添加fallback属性 1234@FeignClient(name="spring-cloud-producer",fallback=HelloRemoteHystrix.class)&#123; @RequestMapping(value = "/hello") public String hello(@RequestParam(value = "name") String name);&#125; 只需要Feign客户端添加fallback属性，指定回调类，就可实现熔断器的功能 一次启动服务中心，提供服务，服务消费三个项目，输入http://localhost:9001/hello/eureka 返回： hello ：eureka 停止服务提供的项目，输入http://localhost:9001/hello/eureka 返回： hello ： eureka ,this message send failed 说明熔断成功。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud之Eureka注册与发现]]></title>
    <url>%2F2019%2F08%2F31%2FSpringCloud%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[服务中心服务中心也称为注册中心。我们可以将自己的某项服务功能注册到服务中心，服务中心可以对我们注册的服务进行发现、负载均衡、熔断、降级等等。 如果没有服务中心的情况下，A项目调用B项目的服务，是直接调用的。 有了服务中心后，项目A不会直接调用项目B的服务。而是从服务中心寻找注册在服务中心的B项目的服务。通过服务中心，间接的调用B项目的服务。 EurekaSpringCloud的一个组件Eureka就能实现服务的注册与发现。Eureka采用CS架构。Eureka Server是服务的注册中心，系统中的其他微服务，通过Eureka Client连接到Eureka Server，并维持心跳连接。这样我们就可以通过Eureka Server来监控某个微服务是否“健康”。如果一个微服务想要调用另一个微服务，就可以通过Eureka Client连接到Eureka Server，在注册中心，找到自己调用的微服务，也就是我们所说的发现。 Eureka由服务端和客户端组成。服务端主要负责服务的注册与发现，以及监控微服务运行的状态的功能。客户端与服务端进行交互，能进行负载均衡相关操作。 Eureka Server 提供服务注册与发现 Service Provider 将微服务注册到服务中心，供其他消费者使用 Service Consumer 从服务中心获取微服务列表，消费微服务 Eureka Server 案例1、添加pom依赖 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、修改application.properties配置文件 12345678spring.application.name=spring-cloud-eurekaserver.port=8000eureka.client.register-with-eureka=false #不要将自己注册进服务中心eureka.client.fetch-registry=false #表示是否从eureka获取注册中心，默认为trueeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;port&#125;/eureka #Eureka Server服务注册与发现的地址，多个地址，可用,隔开 3、添加@EnableEurekaServer注解，启动Eureka服务中心 12345678@SpringBootApplication@EnableEurekaServerpublic class SpringCloudEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudEurekaApplication.class, args); &#125;&#125; 启动工程后，访问：http://localhost:8000/，可以看到下面的页面，其中还没有发现任何服务 Eureka Server高可用集群搭建在实际的生产中，我们需要保证有大于三台服务器来保证服务的高可用。配置原理一样，分别向注册中心注册三台节点，其中一台节点，指向其他两台节点，相关配置如下。 1、application.yml 1234567891011121314151617181920212223242526272829303132333435363738394041---spring: application: name: spring-eureka-server profiles:peer1server: port :8000eureka: instance： hostname: peer1 client: serviceUrl: defaultZone:http://peer2:8001/eureka/,http://peer3:8002/eureka/---spring: application: name: spring-eureka-server profiles: peer2server: port:8001eureka: instance: hostname： peer2 client: serviceUrl: defaultZone: http://peer1:8000/eureka/,http://peer3:80002/eureka/ ---spring: application: name: spring-eureka-server profiles: peer3server: port: 8002eureka: instance: hostname: peer3 client: serviceUrl: defaultZone: http://pee1:8000/eureka/,http://peer2:8001/eureka/ 2、修改hosts文件 127.0.0.1 peer1 127.0.0.1 peer2 127.0.0.1 peer3 3、打包启动 12345mvn clean packagejava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer3 4、启动后，浏览器输入http://localhost:8000/ 服务提供与调用我们已经搭建好了服务中心，怎么使用呢？是不是还缺少服务的提供者与服务的消费者。提供服务的微服务将服务注册到服务中心，服务消费者从服务中获取服务进行服务消费。 服务提供创建一个Springboot项目，作为微服务的提供者 1、添加pom.xml 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、配置application.properties 123spring.application.name=spring-cloud-producerserver.port=9000eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka #将微服务注册到服务中心 3、添加@EnableDiscoveryClient 12345678@SpringBootApplication@EnableDiscoveryClientpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; 4、提供服务 12345678@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index(@RequestParam String name) &#123; return "hello :"+name; &#125;&#125; 到此服务提供完毕。 服务消费1、pom.xml 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、配置application.properties 123spring.application.name=spring-cloud-consumerserver.port=9001eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka 3、添加@EnableDiscoveryClient和EnableFeginClients注解 12345678910@SpringBootApplication@EnableDiscoveryClient //开启服务注册与发现@EnableFeignClients //启动Fegin进行远程调用public class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 1Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单, 它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。 4、fegin调用 123456@FeginClient(name="spring-cloud-producer")&#123;@RequestMapping(value="/hello")public interface HelloRemote(@RequestParam(value="name")String name);&#125; name:表示调用的是哪个微服务的名称 5、调用远程服务 1234567891011@RestControllerpublic class ConsumerController&#123; @Autowired HelloRemote helloRemote; @RequestMapping("/hello/&#123;name&#125;") public String index(@PathVariable("name") String name)&#123; return helloRemote.hello(name); &#125;&#125; 到此服务调用完毕。 分别启动服务中心、服务提供、服务消费项目,输入http://localhost:9001/hello/eureka 返回 hello : eureka 如果启动多个提供服务者实例，你就会发现，同一个请求，会被轮训负载到每一个实例上。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Eureka详解]]></title>
    <url>%2F2019%2F08%2F24%2FSpring-Cloud-Eureka%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Eureka服务体系服务治理是微服务架构中最核心和基础的模块，它主要被用来实现微服务的注册与发现的。 Eureka主要包括两个组件：Eureka Server和Eureka Client。 Eureka Server就是服务的注册中心，它同其他注册中心一样，支持高可用的配置。它支持集群模式部署，当集群中有分片发生故障的时候，Eureka会自动转入自我保护模式，它允许在分片发生故障的时候继续提供服务的注册与发现，当故障分配恢复时，集群中其他分片会把他们的状态再次同步回来。集群中的不同服务注册中心通过异步模式相互复制各自的状态，这也意味着在给定的时间点每个实例关于服务的状态可能存在不一致的现象。 Eureka Client主要处理用户的注册和发现。Eureka客户端向服务注册中心注册自身提供的服务，并周期性的发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地周期性的刷新服务状态。 Eureka服务注册中心在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，包括服务的主机与端口号、服务版本号、通讯协议等一些附加信息。注册中心按照服务名分类组织服务清单，同时还需要以心跳检测的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，以达到排除故障服务的效果。 创建Eureka Server服务添加pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; Eureka Server相关配置我们可以配置项目中的application.properties或者application.yml文件来配置服务中心。 下面是application.yml配置文件的相关配置： 1234567891011server: port: 7001 eureka: instance: hostname: localhost #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka #设置与Eureka交互的地址查询服务和注册服务 启动服务注册中心12345678@EnableEurekaServer //启动服务注册中心@SpringBootApplicationpublic class IefopEurekaServerApplication &#123; publicstatic void main(String[] args) &#123; SpringApplication.run(IefopEurekaServerApplication.class,args); &#125;&#125; Eureka Server集群搭建当服务注册中心发生故障时，必将给整个系统造成瘫痪，因此需要通过实现Eureka Server集群来实现服务的高可用。 Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成互相注册的服务注册中心，实现服务清单的相互同步，达到高可用的效果。 构建注册中心集群分别创建peer1.yml、peer2.yml、peer3.yml配置文件 peer1.yml: 1234567891011server: port: 7001eureka: instance: hostname: peer1 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer2:7002/eureka,http://peer3:7003/eureka #设置其他Eureka服务中心 peer2.yml: 1234567891011server: port: 7002eureka: instance: hostname: peer2 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer1:7001/eureka,http://peer3:7003/eureka #设置其他Eureka服务中心 peer3.xml 1234567891011server: port: 7003eureka: instance: hostname: peer3 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer1:7001/eureka,http://peer2:7002/eureka #设置其他Eureka服务中心 在hosts配置文件中配置域名与ip对应关系 127.0.0.1 peer1 127.0.0.1 peer2 127.0.0.1 peer3 失效剔除有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出、网络故障等原因使服务不能正常运作。而服务注册中心并未收到“服务下线”的请求，为了从服务列表中将这些无法提供服务的实例剔除，Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除出去。 自我保护服务注册到服务中心后，会维持一个心跳连接，告诉Eureka Server自己还活着。Eureka Server在运行期间会统计心跳失败的比例在15分钟以之内是否低于85%，如果出现低于的情况，Eureka Server会将当前实例注册信息保护起来，让这些实例不会过期。这样做会使客户端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况。因此客户端要有容错机制，比如请求重试、断路器。 eureka.server.enableSelfPreservation=true. 可以设置改参数值为false，以确保注册中心将不可用的实例删除 服务提供者服务注册服务提供者在启动的时候会通过REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的一些元数据信息。Eureka Server接收到这个Rest请求之后，将元数据信息存储在一个双层结构的Map中，其中第一层的key是服务名。第二层的key 是具体服务的实例名。 在服务注册时，需要确认一下eureka.client.register-with-eureka=true参数是否正确，该值默认为true。若设置为fasle将不会启动注册操作。 服务同步从eureka服务治理体系架构图中可以看到，不同的服务提供者可以注册在不同的服务注册中心上，它们的信息被不同的服务注册中心维护。 此时，由于多个服务注册中心互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现服务注册中心之间的服务同步。通过服务同步，提供者的服务信息就可以通过集群中的任意一个服务注册中心获得。 服务续约在注册服务之后，服务提供者会维护一个心跳用来持续高速Eureka Server，“我还在持续提供服务”，否则Eureka Server的剔除任务会将该服务实例从服务列表中排除出去。我们称之为服务续约。 下面是服务续约的两个重要属性： eureka.instance.lease-expiration-duration-in-seconds leaseExpirationDurationInSeconds，表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance。 默认为90秒 如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了。 如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉。 该值至少应该大于leaseRenewalIntervalInSeconds eureka.instance.lease-renewal-interval-in-seconds leaseRenewalIntervalInSeconds，表示eureka client发送心跳给server端的频率。如果在leaseExpirationDurationInSeconds后，server端没有收到client的心跳，则将摘除该instance。除此之外，如果该instance实现了HealthCheckCallback，并决定让自己unavailable的话，则该instance也不会接收到流量。 默认30秒 创建并注册服务提供者pom.xml文件依赖如下 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 在Eureka客户端需要在appilication.properties文件中指定服务注册中心的地址application.properties相关配置如下： 1234567server.port=8000eureka.instance.hostname=provider#在此指定服务注册中心地址eureka.client.serviceUrl.defaultZone=http://peer1:7001/eureka/ 启动Eureka客户端 在主类中加入@EnableEurekaClient注解启动Eureka客户端，如下： 1234567891011@EnableEurekaClient@SpringBootApplicationpublic class IefopEurekaClientApplication &#123; publicstatic void main(String[] args) &#123; SpringApplication.run(IefopEurekaClientApplication.class,args); &#125;&#125; 服务消费者获取服务消费者服务启动时，会发送一个Rest请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，Eureka Server会维护一份只读的服务注册清单来返回给客户端，同时该缓存清单默认会每隔30秒更新一次。 下面是获取服务的两个重要的属性： a.client.fetch-registry 是否需要去检索寻找服务，默认是true eureka.client.registry-fetch-interval-seconds 表示eureka client间隔多久去拉取服务注册信息，默认为30秒，对于api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒 服务调用服务消费者在获取服务清单后，通过服务名可以获取具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。 服务下线在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭操作时，会触发一个服务下线的Rest服务请求给Eureka Server，告诉服务注册中心：“我要下线了。”服务端在接收到该请求后，将该服务状态置位下线（DOWN），并把该下线事件传播出去。 配置详解 服务实例类配置端点配置eureka实例的状态页面和健康监控的url默认为spring boot actuator提供的/info端点和/health端点。我们必须确保Eureka客户端的/health端点在发送元数据的时候，是一个能够被注册中心访问到的地址，否则服务注册中心不会根据应用的健康检查来更改状态（仅当开启了healthcheck功能时，以该端点信息作为健康检查标准）。而如果/info端点不正确的话，会导致在Eureka面板中单击服务时，无法访问到服务实例提供的信息接口。 大多数情况下，我们不需要修改这个几个url配置。但是当应用不使用默认的上下文(context path或servlet path，比如配置server.servletPath=/test），或者管理终端路径（比如配置management.contextPath=/admin）时，我们需要修改健康检查和状态页的url地址信息 application.propertiesl配置文件如下： 12345678server.context-path=/helloeureka//下面配置为相对路径，也支持配置成绝对路径，例如需要支持httpseureka.instance.health-check-url-path=$&#123;server.context-path&#125;/healtheureka.instance.status-page-url-path=$&#123;server.context-path&#125;/info 元数据元数据是Eureka客户端在向服务注册中心发送注册请求时，用来描述自身服务信息的对象，其中包含了一些标准化的元数据，比如服务名称、实例名称、实例IP、实例端口等用于服务治理的重要信息；以及一些用于负载均衡策略或是其他特殊用途的自定义元数据信息。 我们可以通过eureka.instance.=的格式对标准化元数据直接进行配置，其中就是EurekaInstanceConfigBean对象中的成员变量。而对于自定义元数据，可以通过eureka.instance.metadataMap.=的格式来进行配置。比如： eureka.instance.metadataMap.zone=tianjin //随机生成实例名 eureka.instance.metadataMap.instanceId=${spring.application.name}:${random.value} 健康检测默认情况下，Eureka中各个服务实例的健康检测并不是通过spring-boot-acturator模块的/health端点来实现的，而是依靠客户端心跳的方式来保持服务实例的存活。在Eureka的服务续约与剔除机制下，客户端的健康状态从注册到注册中心开始都会处于UP状态，除非心跳终止一段时间之后，服务注册中心将其剔除。默认的心跳实现方式可以有效检查客户端进程是否正常运作，但却无法保证客户端应用能够正常提供服务 在Spring Cloud Eureka中，可以把Eureka客户端的健康检测交给spring-boot-actuator模块的health端点，以实现更加全面的健康状态维护，设置方式如下： 在pom.xml中引入spring-boot-starter-actuator模块的依赖 pplication.properties中增加参数配置eureka.client.healthcheck.enabled=true]]></content>
      <categories>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理的区别]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[正向代理​ 正向代理大致原理如下：如果你想访问一下国外的某个网站，但是对于你来说，你是访问不了的，你需要做的就是找到一个可以访问国外网站的一个代理服务器，将自己的请求发送给代理服务器，然后代理服务器会去访问国外的网站服务器，最国外的网站服务器将结果发送给代理服务器，代理服务器再发送给我们。 正向代理主要有以下两个特点： 对于客户端来说，它必须要知道访问服务器的地址。 对于服务器来说，它不清楚请求来自哪个客户端，只知道请求来自哪个代理服务器，正向代理完全屏蔽了客户端的信息。 反向代理当用户访问http://xxxx.com/readme资源时，但是xxxx.com上并不存在readme页面，这时该服务器就会从其他服务器上获取readme资源，并返回给客户端。用户访问的xxx.com这个域名对应的服务器就是设置了反向代理功能，反向代理服务器会通过一系列规则，从后端某个服务器上获取资源，拿到资源后返回给客户端。 反向代理主要特点： 请求的客户端信息对于服务器端来说是已知的。 对于客户端来说，它并不知道自己访问了哪台真实的服务器，反向代理隐藏了服务器的信息。 区别 正向代理需要设置代理服务器ip或者域名进行访问，由代理服务器去获取访问内容并返回；反向代理不需要做任何设置，直接访问服务器真实ip或域名，但是服务器内部会根据访问的内容进行跳转及内容的返回，你最终不知道你访问的是哪台机器。 正向代理代理的是客户端，为客户端收发请求，使真实的客户端对服务器不可见；反向代理代理的是服务器端，为服务器收发请求，使真实的服务器对客户端不可见。 从用途上区分 正向代理：正向代理是为在防火墙内的局域网提供访问Internet的途径，另外还可以使用缓冲特性减少网络使用率。 反向代理：反向代理是将防火墙后面的服务器提供给Internet用户访问，同时还支持负载均衡等功能。 从安全性来讲 正向代理：正向代理允许客户端访问任意网站并且隐蔽客户端自身，因此必须采用安全措施来确保仅为经过授权的客户端提供服务。 反向代理：对外透明，访问者并不知道自己访问的是代理服务器，对于访问者而言，它以为访问的是原始服务器。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理之JDK与CGLIB]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E4%B8%8ECGLIB%2F</url>
    <content type="text"><![CDATA[JDK 动态代理与CGLIB动态代理​ 动态代理是java中常用的设计模式。代理中有两个概念：目标类与代理类。代理类也就是我们所说的中介，对外提供服务时，通过调用代理类就能得到调用目标类的效果，当然，我们会在代理类中添加一些相关的处理。实际上，代理类并不是真正的对外服务的对象，而是通过调用目标类来完成服务的调用的。java中常用的代理方式有两种：JDK动态代理，CGLIB动态代理。 JDK 动态代理​ 对于JDK动态代理来说，就是通过让目标类与代理类实现同一接口，代理类内部持有目标类对象，通过这种方式来达到代理的作用。必须保证两点： 目标类必须实现接口。 如果想要对目标类中的方法进行拦截，必须保证这些方法都在接口中声明。 ​ 要实现JDK动态代理，代理类首先必须要实现InvocationHandler接口，可以看一下该接口定义： 12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[]args) throws Throwable;&#125; ​ 该接口中的invoke方法就是代理类调用目标类方法的入口，通过该方法就能实现代理类完成目标类的代理的作用。 代码演示： Subject接口 1234567public interface Subject &#123; public void rent(); public void hello(String str);&#125; 目标类RealSubject 12345678910111213public class RealSubject implements Subject &#123; @Override public void rent() &#123; System.out.println("I want to rent my house."); &#125; @Override public void hello(String str) &#123; System.out.println("hello:" + str); &#125;&#125; 代理类 12345678910111213141516171819202122232425262728293031public class MyInvocationHandler implements InvocationHandler &#123; //目标对象 Object target; MyInvocationHandler()&#123; super(); &#125; MyInvocationHandler(Object target)&#123; this.target=target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用target之前"); Object invoke = method.invoke(target, args); System.out.println("调用target之后"); return invoke; &#125;&#125; 测试运行 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Subject subject=new RealSubject(); InvocationHandler invocationHandler=new MyInvocationHandler(subject);//创建代理类对象的时候,提供了目标对象类加载器以及目标对象实现的接口与invocationHandler进行绑定 Subject proxyObject = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), invocationHandler); proxyObject.hello("你好呀"); &#125;&#125; 运行结果 调用target之前hello:你好呀调用target之后 CGLIB动态代理​ CGLIB是一个优秀的动态代理框架，它的底层使用ASM在内存中动态生成目标类的子类，因此不能用final修饰目标类，它的使用不需要实现任何接口，简单易用，并且运行速度要高于JDK的动态代理。 目标对象 123456789public class CglibTargetObject &#123; public void doing()&#123; System.out.println("I want to maney"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CglibProxy implements MethodInterceptor &#123; Object target; /** * 创建代理对象 * @param target * @return */ public Object getInstance(Object target)&#123; this.target=target; Enhancer enhancer=new Enhancer(); //设置父类 enhancer.setSuperclass(this.target.getClass()); //设置回调 enhancer.setCallback(this); //创建代理对象 return enhancer.create(); &#125; /** * 回调方法 * @param o * @param method * @param args * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("开始"); System.out.println(method.getName()); Object objectResult = methodProxy.invokeSuper(o, args); System.out.println("结束"); return objectResult; &#125;&#125; 测试 123456CglibProxy cglibProxy=new CglibProxy(); CglibTargetObject cglibProxyInstance=(CglibTargetObject) cglibProxy.getInstance(new CglibTargetObject()); cglibProxyInstance.doing(); 总结1、如果目标对象实现了接口，就可以采用JDK动态代理的形式来为目标类实现代理。 2、如果目标对象没有实现接口，采用CGLIB的方式，生成目标对象的子类，实现动态代理类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud重要知识点学习]]></title>
    <url>%2F2019%2F08%2F11%2FSpringCloud%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[微服务​ 个人理解，微服务架构是一种架构模式，*它提倡将单一应用程序(也就是我们开发的一整个项目)划分成一组小的服务，每一种服务都有自己的进程 *。例如，我们可以将电商网站划分为订单服务、评价服务、购物车服务等等一系列轻量级的服务(通常基于HTTP RESTful API调用)，各个服务之间可以相互调用、相互配合，每一个服务都相互独立。 ​ 微服务的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底的去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事。每一个服务可以采用不同的技术以及数据库技术。 ​ 下面通过两张图了解传统系统架构与微服务的区别： 传统系统架构图： ​ 从该图中，不难发现，系统中所有的服务都部署在一台主机上，并且又这些主机构成服务集群。这种架构的缺点就是，一旦某项服务出现了问题就会涉及到其他相关应用，并不能很好的做好低耦合性。 微服务架构图： ​ 微服务架构根据业务将各项服务组件相互独立出来，每项服务都是一个独立的模块，甚至可以采用不同的编程语言实现业务相关代码。 微服务与微服务架构的区别微服务​ 微服务强调的是一个个体，他关注的是某一个点。它是对具体问题提供的一个具体的服务。例如，电商系统中的支付功能就是一个微服务，它是为了解决某项具体问题的服务。 微服务架构​ 微服务架构是一种模式，它将单一的应用划分成一组小的服务，每一种服务都相互独立，各个服务之间相互调用与协调，每一种服务都有自己的进程，各个服务之间通过轻量级HTTP协议的RESTful API进行通讯，对外提供服务。 微服务优缺点优点：1. 每个服务足够内聚，足够小，一个服务只做一件事情。 微服务只是业务逻辑代码，不会和HTML,CSS以及其他组件混合。 每个微服务都相互独立，可以使用不同的语言开发，可以使用自己的数据库，也可以使用统一的数据库。 缺点：1. 分布式系统的复杂性大 服务间的通讯成本增加 数据一致性问题 随着服务增加，系统运维的压力较大 Spring Cloud​ SpringCloud是基于SpringBoot提供的一套微服务解决方案。包括服务注册与发现、配置中心、全链路监控、服务网关、负载均衡、熔断器等组件。简单来说，SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体。 ​ SpringBoot与SpringCloud有什么关系呢？ ​ SpringBoot专注于单个微服务的开发。SpringCloud是关注与全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合起来，为个个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。 ​ SpringBoot可以离开SpringCloud单独开发，SpringCloud离不开SpringBoot。 ​ 总结：SpringBoot专注于单个微服务开发，SpringCloud关注全局的服务治理。 ​]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
