<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态代理之JDK与CGLIB]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E4%B8%8ECGLIB%2F</url>
    <content type="text"><![CDATA[JDK 动态代理与CGLIB动态代理​ 动态代理是java中常用的设计模式。代理中有两个概念：目标类与代理类。代理类也就是我们所说的中介，对外提供服务时，通过调用代理类就能得到调用目标类的效果，当然，我们会在代理类中添加一些相关的处理。实际上，代理类并不是真正的对外服务的对象，而是通过调用目标类来完成服务的调用的。java中常用的代理方式有两种：JDK动态代理，CGLIB动态代理。 JDK 动态代理​ 对于JDK动态代理来说，就是通过让目标类与代理类实现同一接口，代理类内部持有目标类对象，通过这种方式来达到代理的作用。必须保证两点： 目标类必须实现接口。 如果想要对目标类中的方法进行拦截，必须保证这些方法都在接口中声明。 ​ 要实现JDK动态代理，代理类首先必须要实现InvocationHandler接口，可以看一下该接口定义： 12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[]args) throws Throwable;&#125; ​ 该接口中的invoke方法就是代理类调用目标类方法的入口，通过该方法就能实现代理类完成目标类的代理的作用。 代码演示： Subject接口 1234567public interface Subject &#123; public void rent(); public void hello(String str);&#125; 目标类RealSubject 12345678910111213public class RealSubject implements Subject &#123; @Override public void rent() &#123; System.out.println("I want to rent my house."); &#125; @Override public void hello(String str) &#123; System.out.println("hello:" + str); &#125;&#125; 代理类 12345678910111213141516171819202122232425262728293031public class MyInvocationHandler implements InvocationHandler &#123; //目标对象 Object target; MyInvocationHandler()&#123; super(); &#125; MyInvocationHandler(Object target)&#123; this.target=target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用target之前"); Object invoke = method.invoke(target, args); System.out.println("调用target之后"); return invoke; &#125;&#125; 测试运行 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Subject subject=new RealSubject(); InvocationHandler invocationHandler=new MyInvocationHandler(subject);//创建代理类对象的时候,提供了目标对象类加载器以及目标对象实现的接口与invocationHandler进行绑定 Subject proxyObject = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), invocationHandler); proxyObject.hello("你好呀"); &#125;&#125; 运行结果 调用target之前hello:你好呀调用target之后 CGLIB动态代理​ CGLIB是一个优秀的动态代理框架，它的底层使用ASM在内存中动态生成目标类的子类，因此不能用final修饰目标类，它的使用不需要实现任何接口，简单易用，并且运行速度要高于JDK的动态代理。 目标对象 123456789public class CglibTargetObject &#123; public void doing()&#123; System.out.println("I want to maney"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CglibProxy implements MethodInterceptor &#123; Object target; /** * 创建代理对象 * @param target * @return */ public Object getInstance(Object target)&#123; this.target=target; Enhancer enhancer=new Enhancer(); //设置父类 enhancer.setSuperclass(this.target.getClass()); //设置回调 enhancer.setCallback(this); //创建代理对象 return enhancer.create(); &#125; /** * 回调方法 * @param o * @param method * @param args * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("开始"); System.out.println(method.getName()); Object objectResult = methodProxy.invokeSuper(o, args); System.out.println("结束"); return objectResult; &#125;&#125; 测试 123456CglibProxy cglibProxy=new CglibProxy(); CglibTargetObject cglibProxyInstance=(CglibTargetObject) cglibProxy.getInstance(new CglibTargetObject()); cglibProxyInstance.doing(); 总结1、如果目标对象实现了接口，就可以采用JDK动态代理的形式来为目标类实现代理。 2、如果目标对象没有实现接口，采用CGLIB的方式，生成目标对象的子类，实现动态代理类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud重要知识点学习]]></title>
    <url>%2F2019%2F08%2F11%2FSpringCloud%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[微服务​ 个人理解，微服务架构是一种架构模式，*它提倡将单一应用程序(也就是我们开发的一整个项目)划分成一组小的服务，每一种服务都有自己的进程 *。例如，我们可以将电商网站划分为订单服务、评价服务、购物车服务等等一系列轻量级的服务(通常基于HTTP RESTful API调用)，各个服务之间可以相互调用、相互配合，每一个服务都相互独立。 ​ 微服务的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底的去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事。每一个服务可以采用不同的技术以及数据库技术。 ​ 下面通过两张图了解传统系统架构与微服务的区别： 传统系统架构图： ​ 从该图中，不难发现，系统中所有的服务都部署在一台主机上，并且又这些主机构成服务集群。这种架构的缺点就是，一旦某项服务出现了问题就会涉及到其他相关应用，并不能很好的做好低耦合性。 微服务架构图： ​ 微服务架构根据业务将各项服务组件相互独立出来，每项服务都是一个独立的模块，甚至可以采用不同的编程语言实现业务相关代码。 微服务与微服务架构的区别微服务​ 微服务强调的是一个个体，他关注的是某一个点。它是对具体问题提供的一个具体的服务。例如，电商系统中的支付功能就是一个微服务，它是为了解决某项具体问题的服务。 微服务架构​ 微服务架构是一种模式，它将单一的应用划分成一组小的服务，每一种服务都相互独立，各个服务之间相互调用与协调，每一种服务都有自己的进程，各个服务之间通过轻量级HTTP协议的RESTful API进行通讯，对外提供服务。 微服务优缺点优点：1. 每个服务足够内聚，足够小，一个服务只做一件事情。 微服务只是业务逻辑代码，不会和HTML,CSS以及其他组件混合。 每个微服务都相互独立，可以使用不同的语言开发，可以使用自己的数据库，也可以使用统一的数据库。 缺点：1. 分布式系统的复杂性大 服务间的通讯成本增加 数据一致性问题 随着服务增加，系统运维的压力较大 Spring Cloud​ SpringCloud是基于SpringBoot提供的一套微服务解决方案。包括服务注册与发现、配置中心、全链路监控、服务网关、负载均衡、熔断器等组件。简单来说，SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体。 ​ SpringBoot与SpringCloud有什么关系呢？ ​ SpringBoot专注于单个微服务的开发。SpringCloud是关注与全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合起来，为个个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。 ​ SpringBoot可以离开SpringCloud单独开发，SpringCloud离不开SpringBoot。 ​ 总结：SpringBoot专注于单个微服务开发，SpringCloud关注全局的服务治理。 ​]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之数组链表]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[nginx知识点全面学习]]></title>
    <url>%2F2019%2F07%2F22%2Fnginx%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A8%E9%9D%A2%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Nginx是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。在高连接并发的情况下，Nginx是Apache服务器不错的替代品。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2019%2F07%2F22%2Fjava%2F</url>
    <content type="text"><![CDATA[java 是我最擅长的语言]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
