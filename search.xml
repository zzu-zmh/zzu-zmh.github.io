<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正向代理与反向代理的区别]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[正向代理​ 正向代理大致原理如下：如果你想访问一下国外的某个网站，但是对于你来说，你是访问不了的，你需要做的就是找到一个可以访问国外网站的一个代理服务器，将自己的请求发送给代理服务器，然后代理服务器会去访问国外的网站服务器，最国外的网站服务器将结果发送给代理服务器，代理服务器再发送给我们。 正向代理主要有以下两个特点： 对于客户端来说，它必须要知道访问服务器的地址。 对于服务器来说，它不清楚请求来自哪个客户端，只知道请求来自哪个代理服务器，正向代理完全屏蔽了客户端的信息。 反向代理当用户访问http://xxxx.com/readme资源时，但是xxxx.com上并不存在readme页面，这时该服务器就会从其他服务器上获取readme资源，并返回给客户端。用户访问的xxx.com这个域名对应的服务器就是设置了反向代理功能，反向代理服务器会通过一系列规则，从后端某个服务器上获取资源，拿到资源后返回给客户端。 反向代理主要特点： 请求的客户端信息对于服务器端来说是已知的。 对于客户端来说，它并不知道自己访问了哪台真实的服务器，反向代理隐藏了服务器的信息。 区别 正向代理需要设置代理服务器ip或者域名进行访问，由代理服务器去获取访问内容并返回；反向代理不需要做任何设置，直接访问服务器真实ip或域名，但是服务器内部会根据访问的内容进行跳转及内容的返回，你最终不知道你访问的是哪台机器。 正向代理代理的是客户端，为客户端收发请求，使真实的客户端对服务器不可见；反向代理代理的是服务器端，为服务器收发请求，使真实的服务器对客户端不可见。 从用途上区分 正向代理：正向代理是为在防火墙内的局域网提供访问Internet的途径，另外还可以使用缓冲特性减少网络使用率。 反向代理：反向代理是将防火墙后面的服务器提供给Internet用户访问，同时还支持负载均衡等功能。 从安全性来讲 正向代理：正向代理允许客户端访问任意网站并且隐蔽客户端自身，因此必须采用安全措施来确保仅为经过授权的客户端提供服务。 反向代理：对外透明，访问者并不知道自己访问的是代理服务器，对于访问者而言，它以为访问的是原始服务器。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理之JDK与CGLIB]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E4%B8%8ECGLIB%2F</url>
    <content type="text"><![CDATA[JDK 动态代理与CGLIB动态代理​ 动态代理是java中常用的设计模式。代理中有两个概念：目标类与代理类。代理类也就是我们所说的中介，对外提供服务时，通过调用代理类就能得到调用目标类的效果，当然，我们会在代理类中添加一些相关的处理。实际上，代理类并不是真正的对外服务的对象，而是通过调用目标类来完成服务的调用的。java中常用的代理方式有两种：JDK动态代理，CGLIB动态代理。 JDK 动态代理​ 对于JDK动态代理来说，就是通过让目标类与代理类实现同一接口，代理类内部持有目标类对象，通过这种方式来达到代理的作用。必须保证两点： 目标类必须实现接口。 如果想要对目标类中的方法进行拦截，必须保证这些方法都在接口中声明。 ​ 要实现JDK动态代理，代理类首先必须要实现InvocationHandler接口，可以看一下该接口定义： 12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[]args) throws Throwable;&#125; ​ 该接口中的invoke方法就是代理类调用目标类方法的入口，通过该方法就能实现代理类完成目标类的代理的作用。 代码演示： Subject接口 1234567public interface Subject &#123; public void rent(); public void hello(String str);&#125; 目标类RealSubject 12345678910111213public class RealSubject implements Subject &#123; @Override public void rent() &#123; System.out.println("I want to rent my house."); &#125; @Override public void hello(String str) &#123; System.out.println("hello:" + str); &#125;&#125; 代理类 12345678910111213141516171819202122232425262728293031public class MyInvocationHandler implements InvocationHandler &#123; //目标对象 Object target; MyInvocationHandler()&#123; super(); &#125; MyInvocationHandler(Object target)&#123; this.target=target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用target之前"); Object invoke = method.invoke(target, args); System.out.println("调用target之后"); return invoke; &#125;&#125; 测试运行 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Subject subject=new RealSubject(); InvocationHandler invocationHandler=new MyInvocationHandler(subject);//创建代理类对象的时候,提供了目标对象类加载器以及目标对象实现的接口与invocationHandler进行绑定 Subject proxyObject = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), invocationHandler); proxyObject.hello("你好呀"); &#125;&#125; 运行结果 调用target之前hello:你好呀调用target之后 CGLIB动态代理​ CGLIB是一个优秀的动态代理框架，它的底层使用ASM在内存中动态生成目标类的子类，因此不能用final修饰目标类，它的使用不需要实现任何接口，简单易用，并且运行速度要高于JDK的动态代理。 目标对象 123456789public class CglibTargetObject &#123; public void doing()&#123; System.out.println("I want to maney"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CglibProxy implements MethodInterceptor &#123; Object target; /** * 创建代理对象 * @param target * @return */ public Object getInstance(Object target)&#123; this.target=target; Enhancer enhancer=new Enhancer(); //设置父类 enhancer.setSuperclass(this.target.getClass()); //设置回调 enhancer.setCallback(this); //创建代理对象 return enhancer.create(); &#125; /** * 回调方法 * @param o * @param method * @param args * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("开始"); System.out.println(method.getName()); Object objectResult = methodProxy.invokeSuper(o, args); System.out.println("结束"); return objectResult; &#125;&#125; 测试 123456CglibProxy cglibProxy=new CglibProxy(); CglibTargetObject cglibProxyInstance=(CglibTargetObject) cglibProxy.getInstance(new CglibTargetObject()); cglibProxyInstance.doing(); 总结1、如果目标对象实现了接口，就可以采用JDK动态代理的形式来为目标类实现代理。 2、如果目标对象没有实现接口，采用CGLIB的方式，生成目标对象的子类，实现动态代理类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud重要知识点学习]]></title>
    <url>%2F2019%2F08%2F11%2FSpringCloud%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[微服务​ 个人理解，微服务架构是一种架构模式，*它提倡将单一应用程序(也就是我们开发的一整个项目)划分成一组小的服务，每一种服务都有自己的进程 *。例如，我们可以将电商网站划分为订单服务、评价服务、购物车服务等等一系列轻量级的服务(通常基于HTTP RESTful API调用)，各个服务之间可以相互调用、相互配合，每一个服务都相互独立。 ​ 微服务的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底的去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事。每一个服务可以采用不同的技术以及数据库技术。 ​ 下面通过两张图了解传统系统架构与微服务的区别： 传统系统架构图： ​ 从该图中，不难发现，系统中所有的服务都部署在一台主机上，并且又这些主机构成服务集群。这种架构的缺点就是，一旦某项服务出现了问题就会涉及到其他相关应用，并不能很好的做好低耦合性。 微服务架构图： ​ 微服务架构根据业务将各项服务组件相互独立出来，每项服务都是一个独立的模块，甚至可以采用不同的编程语言实现业务相关代码。 微服务与微服务架构的区别微服务​ 微服务强调的是一个个体，他关注的是某一个点。它是对具体问题提供的一个具体的服务。例如，电商系统中的支付功能就是一个微服务，它是为了解决某项具体问题的服务。 微服务架构​ 微服务架构是一种模式，它将单一的应用划分成一组小的服务，每一种服务都相互独立，各个服务之间相互调用与协调，每一种服务都有自己的进程，各个服务之间通过轻量级HTTP协议的RESTful API进行通讯，对外提供服务。 微服务优缺点优点：1. 每个服务足够内聚，足够小，一个服务只做一件事情。 微服务只是业务逻辑代码，不会和HTML,CSS以及其他组件混合。 每个微服务都相互独立，可以使用不同的语言开发，可以使用自己的数据库，也可以使用统一的数据库。 缺点：1. 分布式系统的复杂性大 服务间的通讯成本增加 数据一致性问题 随着服务增加，系统运维的压力较大 Spring Cloud​ SpringCloud是基于SpringBoot提供的一套微服务解决方案。包括服务注册与发现、配置中心、全链路监控、服务网关、负载均衡、熔断器等组件。简单来说，SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体。 ​ SpringBoot与SpringCloud有什么关系呢？ ​ SpringBoot专注于单个微服务的开发。SpringCloud是关注与全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合起来，为个个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。 ​ SpringBoot可以离开SpringCloud单独开发，SpringCloud离不开SpringBoot。 ​ 总结：SpringBoot专注于单个微服务开发，SpringCloud关注全局的服务治理。 ​]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
