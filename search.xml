<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud Eureka详解]]></title>
    <url>%2F2019%2F08%2F24%2FSpring-Cloud-Eureka%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Eureka服务体系服务治理是微服务架构中最核心和基础的模块，它主要被用来实现微服务的注册与发现的。 Eureka主要包括两个组件：Eureka Server和Eureka Client。 Eureka Server就是服务的注册中心，它同其他注册中心一样，支持高可用的配置。它支持集群模式部署，当集群中有分片发生故障的时候，Eureka会自动转入自我保护模式，它允许在分片发生故障的时候继续提供服务的注册与发现，当故障分配恢复时，集群中其他分片会把他们的状态再次同步回来。集群中的不同服务注册中心通过异步模式相互复制各自的状态，这也意味着在给定的时间点每个实例关于服务的状态可能存在不一致的现象。 Eureka Client主要处理用户的注册和发现。Eureka客户端向服务注册中心注册自身提供的服务，并周期性的发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地周期性的刷新服务状态。 Eureka服务注册中心在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，包括服务的主机与端口号、服务版本号、通讯协议等一些附加信息。注册中心按照服务名分类组织服务清单，同时还需要以心跳检测的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，以达到排除故障服务的效果。 创建Eureka Server服务添加pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; Eureka Server相关配置我们可以配置项目中的application.properties或者application.yml文件来配置服务中心。 下面是application.yml配置文件的相关配置： 1234567891011server: port: 7001 eureka: instance: hostname: localhost #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka #设置与Eureka交互的地址查询服务和注册服务 启动服务注册中心12345678@EnableEurekaServer //启动服务注册中心@SpringBootApplicationpublic class IefopEurekaServerApplication &#123; publicstatic void main(String[] args) &#123; SpringApplication.run(IefopEurekaServerApplication.class,args); &#125;&#125; Eureka Server集群搭建当服务注册中心发生故障时，必将给整个系统造成瘫痪，因此需要通过实现Eureka Server集群来实现服务的高可用。 Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成互相注册的服务注册中心，实现服务清单的相互同步，达到高可用的效果。 构建注册中心集群分别创建peer1.yml、peer2.yml、peer3.yml配置文件 peer1.yml: 1234567891011server: port: 7001eureka: instance: hostname: peer1 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer2:7002/eureka,http://peer3:7003/eureka #设置其他Eureka服务中心 peer2.yml: 1234567891011server: port: 7002eureka: instance: hostname: peer2 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer1:7001/eureka,http://peer3:7003/eureka #设置其他Eureka服务中心 peer3.xml 1234567891011server: port: 7003eureka: instance: hostname: peer3 #eureka服务端的实力名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己端就是注册中心 serviceUrl: defaultZone: http://peer1:7001/eureka,http://peer2:7002/eureka #设置其他Eureka服务中心 在hosts配置文件中配置域名与ip对应关系 127.0.0.1 peer1 127.0.0.1 peer2 127.0.0.1 peer3 失效剔除有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出、网络故障等原因使服务不能正常运作。而服务注册中心并未收到“服务下线”的请求，为了从服务列表中将这些无法提供服务的实例剔除，Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除出去。 自我保护服务注册到服务中心后，会维持一个心跳连接，告诉Eureka Server自己还活着。Eureka Server在运行期间会统计心跳失败的比例在15分钟以之内是否低于85%，如果出现低于的情况，Eureka Server会将当前实例注册信息保护起来，让这些实例不会过期。这样做会使客户端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况。因此客户端要有容错机制，比如请求重试、断路器。 eureka.server.enableSelfPreservation=true. 可以设置改参数值为false，以确保注册中心将不可用的实例删除 服务提供者服务注册服务提供者在启动的时候会通过REST请求的方式将自己注册到Eureka Server上，同时带上自身服务的一些元数据信息。Eureka Server接收到这个Rest请求之后，将元数据信息存储在一个双层结构的Map中，其中第一层的key是服务名。第二层的key 是具体服务的实例名。 在服务注册时，需要确认一下eureka.client.register-with-eureka=true参数是否正确，该值默认为true。若设置为fasle将不会启动注册操作。 服务同步从eureka服务治理体系架构图中可以看到，不同的服务提供者可以注册在不同的服务注册中心上，它们的信息被不同的服务注册中心维护。 此时，由于多个服务注册中心互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现服务注册中心之间的服务同步。通过服务同步，提供者的服务信息就可以通过集群中的任意一个服务注册中心获得。 服务续约在注册服务之后，服务提供者会维护一个心跳用来持续高速Eureka Server，“我还在持续提供服务”，否则Eureka Server的剔除任务会将该服务实例从服务列表中排除出去。我们称之为服务续约。 下面是服务续约的两个重要属性： eureka.instance.lease-expiration-duration-in-seconds leaseExpirationDurationInSeconds，表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance。 默认为90秒 如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了。 如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉。 该值至少应该大于leaseRenewalIntervalInSeconds eureka.instance.lease-renewal-interval-in-seconds leaseRenewalIntervalInSeconds，表示eureka client发送心跳给server端的频率。如果在leaseExpirationDurationInSeconds后，server端没有收到client的心跳，则将摘除该instance。除此之外，如果该instance实现了HealthCheckCallback，并决定让自己unavailable的话，则该instance也不会接收到流量。 默认30秒 创建并注册服务提供者pom.xml文件依赖如下 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 在Eureka客户端需要在appilication.properties文件中指定服务注册中心的地址application.properties相关配置如下： 1234567server.port=8000eureka.instance.hostname=provider#在此指定服务注册中心地址eureka.client.serviceUrl.defaultZone=http://peer1:7001/eureka/ 启动Eureka客户端 在主类中加入@EnableEurekaClient注解启动Eureka客户端，如下： 1234567891011@EnableEurekaClient@SpringBootApplicationpublic class IefopEurekaClientApplication &#123; publicstatic void main(String[] args) &#123; SpringApplication.run(IefopEurekaClientApplication.class,args); &#125;&#125; 服务消费者获取服务消费者服务启动时，会发送一个Rest请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，Eureka Server会维护一份只读的服务注册清单来返回给客户端，同时该缓存清单默认会每隔30秒更新一次。 下面是获取服务的两个重要的属性： a.client.fetch-registry 是否需要去检索寻找服务，默认是true eureka.client.registry-fetch-interval-seconds 表示eureka client间隔多久去拉取服务注册信息，默认为30秒，对于api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒 服务调用服务消费者在获取服务清单后，通过服务名可以获取具体提供服务的实例名和该实例的元数据信息。因为有这些服务实例的详细信息，所以客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。 服务下线在系统运行过程中必然会面临关闭或重启服务的某个实例的情况，在服务关闭操作时，会触发一个服务下线的Rest服务请求给Eureka Server，告诉服务注册中心：“我要下线了。”服务端在接收到该请求后，将该服务状态置位下线（DOWN），并把该下线事件传播出去。 配置详解 服务实例类配置端点配置eureka实例的状态页面和健康监控的url默认为spring boot actuator提供的/info端点和/health端点。我们必须确保Eureka客户端的/health端点在发送元数据的时候，是一个能够被注册中心访问到的地址，否则服务注册中心不会根据应用的健康检查来更改状态（仅当开启了healthcheck功能时，以该端点信息作为健康检查标准）。而如果/info端点不正确的话，会导致在Eureka面板中单击服务时，无法访问到服务实例提供的信息接口。 大多数情况下，我们不需要修改这个几个url配置。但是当应用不使用默认的上下文(context path或servlet path，比如配置server.servletPath=/test），或者管理终端路径（比如配置management.contextPath=/admin）时，我们需要修改健康检查和状态页的url地址信息 application.propertiesl配置文件如下： 12345678server.context-path=/helloeureka//下面配置为相对路径，也支持配置成绝对路径，例如需要支持httpseureka.instance.health-check-url-path=$&#123;server.context-path&#125;/healtheureka.instance.status-page-url-path=$&#123;server.context-path&#125;/info 元数据元数据是Eureka客户端在向服务注册中心发送注册请求时，用来描述自身服务信息的对象，其中包含了一些标准化的元数据，比如服务名称、实例名称、实例IP、实例端口等用于服务治理的重要信息；以及一些用于负载均衡策略或是其他特殊用途的自定义元数据信息。 我们可以通过eureka.instance.=的格式对标准化元数据直接进行配置，其中就是EurekaInstanceConfigBean对象中的成员变量。而对于自定义元数据，可以通过eureka.instance.metadataMap.=的格式来进行配置。比如： eureka.instance.metadataMap.zone=tianjin //随机生成实例名 eureka.instance.metadataMap.instanceId=${spring.application.name}:${random.value} 健康检测默认情况下，Eureka中各个服务实例的健康检测并不是通过spring-boot-acturator模块的/health端点来实现的，而是依靠客户端心跳的方式来保持服务实例的存活。在Eureka的服务续约与剔除机制下，客户端的健康状态从注册到注册中心开始都会处于UP状态，除非心跳终止一段时间之后，服务注册中心将其剔除。默认的心跳实现方式可以有效检查客户端进程是否正常运作，但却无法保证客户端应用能够正常提供服务 在Spring Cloud Eureka中，可以把Eureka客户端的健康检测交给spring-boot-actuator模块的health端点，以实现更加全面的健康状态维护，设置方式如下： 在pom.xml中引入spring-boot-starter-actuator模块的依赖 pplication.properties中增加参数配置eureka.client.healthcheck.enabled=true]]></content>
      <categories>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2019%2F08%2F18%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理的区别]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[正向代理​ 正向代理大致原理如下：如果你想访问一下国外的某个网站，但是对于你来说，你是访问不了的，你需要做的就是找到一个可以访问国外网站的一个代理服务器，将自己的请求发送给代理服务器，然后代理服务器会去访问国外的网站服务器，最国外的网站服务器将结果发送给代理服务器，代理服务器再发送给我们。 正向代理主要有以下两个特点： 对于客户端来说，它必须要知道访问服务器的地址。 对于服务器来说，它不清楚请求来自哪个客户端，只知道请求来自哪个代理服务器，正向代理完全屏蔽了客户端的信息。 反向代理当用户访问http://xxxx.com/readme资源时，但是xxxx.com上并不存在readme页面，这时该服务器就会从其他服务器上获取readme资源，并返回给客户端。用户访问的xxx.com这个域名对应的服务器就是设置了反向代理功能，反向代理服务器会通过一系列规则，从后端某个服务器上获取资源，拿到资源后返回给客户端。 反向代理主要特点： 请求的客户端信息对于服务器端来说是已知的。 对于客户端来说，它并不知道自己访问了哪台真实的服务器，反向代理隐藏了服务器的信息。 区别 正向代理需要设置代理服务器ip或者域名进行访问，由代理服务器去获取访问内容并返回；反向代理不需要做任何设置，直接访问服务器真实ip或域名，但是服务器内部会根据访问的内容进行跳转及内容的返回，你最终不知道你访问的是哪台机器。 正向代理代理的是客户端，为客户端收发请求，使真实的客户端对服务器不可见；反向代理代理的是服务器端，为服务器收发请求，使真实的服务器对客户端不可见。 从用途上区分 正向代理：正向代理是为在防火墙内的局域网提供访问Internet的途径，另外还可以使用缓冲特性减少网络使用率。 反向代理：反向代理是将防火墙后面的服务器提供给Internet用户访问，同时还支持负载均衡等功能。 从安全性来讲 正向代理：正向代理允许客户端访问任意网站并且隐蔽客户端自身，因此必须采用安全措施来确保仅为经过授权的客户端提供服务。 反向代理：对外透明，访问者并不知道自己访问的是代理服务器，对于访问者而言，它以为访问的是原始服务器。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理之JDK与CGLIB]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E4%B8%8ECGLIB%2F</url>
    <content type="text"><![CDATA[JDK 动态代理与CGLIB动态代理​ 动态代理是java中常用的设计模式。代理中有两个概念：目标类与代理类。代理类也就是我们所说的中介，对外提供服务时，通过调用代理类就能得到调用目标类的效果，当然，我们会在代理类中添加一些相关的处理。实际上，代理类并不是真正的对外服务的对象，而是通过调用目标类来完成服务的调用的。java中常用的代理方式有两种：JDK动态代理，CGLIB动态代理。 JDK 动态代理​ 对于JDK动态代理来说，就是通过让目标类与代理类实现同一接口，代理类内部持有目标类对象，通过这种方式来达到代理的作用。必须保证两点： 目标类必须实现接口。 如果想要对目标类中的方法进行拦截，必须保证这些方法都在接口中声明。 ​ 要实现JDK动态代理，代理类首先必须要实现InvocationHandler接口，可以看一下该接口定义： 12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[]args) throws Throwable;&#125; ​ 该接口中的invoke方法就是代理类调用目标类方法的入口，通过该方法就能实现代理类完成目标类的代理的作用。 代码演示： Subject接口 1234567public interface Subject &#123; public void rent(); public void hello(String str);&#125; 目标类RealSubject 12345678910111213public class RealSubject implements Subject &#123; @Override public void rent() &#123; System.out.println("I want to rent my house."); &#125; @Override public void hello(String str) &#123; System.out.println("hello:" + str); &#125;&#125; 代理类 12345678910111213141516171819202122232425262728293031public class MyInvocationHandler implements InvocationHandler &#123; //目标对象 Object target; MyInvocationHandler()&#123; super(); &#125; MyInvocationHandler(Object target)&#123; this.target=target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用target之前"); Object invoke = method.invoke(target, args); System.out.println("调用target之后"); return invoke; &#125;&#125; 测试运行 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Subject subject=new RealSubject(); InvocationHandler invocationHandler=new MyInvocationHandler(subject);//创建代理类对象的时候,提供了目标对象类加载器以及目标对象实现的接口与invocationHandler进行绑定 Subject proxyObject = (Subject) Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), invocationHandler); proxyObject.hello("你好呀"); &#125;&#125; 运行结果 调用target之前hello:你好呀调用target之后 CGLIB动态代理​ CGLIB是一个优秀的动态代理框架，它的底层使用ASM在内存中动态生成目标类的子类，因此不能用final修饰目标类，它的使用不需要实现任何接口，简单易用，并且运行速度要高于JDK的动态代理。 目标对象 123456789public class CglibTargetObject &#123; public void doing()&#123; System.out.println("I want to maney"); &#125;&#125; 代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CglibProxy implements MethodInterceptor &#123; Object target; /** * 创建代理对象 * @param target * @return */ public Object getInstance(Object target)&#123; this.target=target; Enhancer enhancer=new Enhancer(); //设置父类 enhancer.setSuperclass(this.target.getClass()); //设置回调 enhancer.setCallback(this); //创建代理对象 return enhancer.create(); &#125; /** * 回调方法 * @param o * @param method * @param args * @param methodProxy * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("开始"); System.out.println(method.getName()); Object objectResult = methodProxy.invokeSuper(o, args); System.out.println("结束"); return objectResult; &#125;&#125; 测试 123456CglibProxy cglibProxy=new CglibProxy(); CglibTargetObject cglibProxyInstance=(CglibTargetObject) cglibProxy.getInstance(new CglibTargetObject()); cglibProxyInstance.doing(); 总结1、如果目标对象实现了接口，就可以采用JDK动态代理的形式来为目标类实现代理。 2、如果目标对象没有实现接口，采用CGLIB的方式，生成目标对象的子类，实现动态代理类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud重要知识点学习]]></title>
    <url>%2F2019%2F08%2F11%2FSpringCloud%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[微服务​ 个人理解，微服务架构是一种架构模式，*它提倡将单一应用程序(也就是我们开发的一整个项目)划分成一组小的服务，每一种服务都有自己的进程 *。例如，我们可以将电商网站划分为订单服务、评价服务、购物车服务等等一系列轻量级的服务(通常基于HTTP RESTful API调用)，各个服务之间可以相互调用、相互配合，每一个服务都相互独立。 ​ 微服务的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底的去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事。每一个服务可以采用不同的技术以及数据库技术。 ​ 下面通过两张图了解传统系统架构与微服务的区别： 传统系统架构图： ​ 从该图中，不难发现，系统中所有的服务都部署在一台主机上，并且又这些主机构成服务集群。这种架构的缺点就是，一旦某项服务出现了问题就会涉及到其他相关应用，并不能很好的做好低耦合性。 微服务架构图： ​ 微服务架构根据业务将各项服务组件相互独立出来，每项服务都是一个独立的模块，甚至可以采用不同的编程语言实现业务相关代码。 微服务与微服务架构的区别微服务​ 微服务强调的是一个个体，他关注的是某一个点。它是对具体问题提供的一个具体的服务。例如，电商系统中的支付功能就是一个微服务，它是为了解决某项具体问题的服务。 微服务架构​ 微服务架构是一种模式，它将单一的应用划分成一组小的服务，每一种服务都相互独立，各个服务之间相互调用与协调，每一种服务都有自己的进程，各个服务之间通过轻量级HTTP协议的RESTful API进行通讯，对外提供服务。 微服务优缺点优点：1. 每个服务足够内聚，足够小，一个服务只做一件事情。 微服务只是业务逻辑代码，不会和HTML,CSS以及其他组件混合。 每个微服务都相互独立，可以使用不同的语言开发，可以使用自己的数据库，也可以使用统一的数据库。 缺点：1. 分布式系统的复杂性大 服务间的通讯成本增加 数据一致性问题 随着服务增加，系统运维的压力较大 Spring Cloud​ SpringCloud是基于SpringBoot提供的一套微服务解决方案。包括服务注册与发现、配置中心、全链路监控、服务网关、负载均衡、熔断器等组件。简单来说，SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体。 ​ SpringBoot与SpringCloud有什么关系呢？ ​ SpringBoot专注于单个微服务的开发。SpringCloud是关注与全局的微服务协调治理框架，它将SpringBoot开发的一个个单体微服务整合起来，为个个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。 ​ SpringBoot可以离开SpringCloud单独开发，SpringCloud离不开SpringBoot。 ​ 总结：SpringBoot专注于单个微服务开发，SpringCloud关注全局的服务治理。 ​]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
